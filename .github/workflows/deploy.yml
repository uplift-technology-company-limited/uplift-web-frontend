name: ğŸš€ Uplift Web Frontend CI/CD

on:
  push:
    branches: [main, dev, develop]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - production
          - development

env:
  NODE_VERSION: "22"
  AWS_REGION: "ap-southeast-1"
  ECR_REPOSITORY: "uplifttech/uplift-web-frontend"
  ECS_CLUSTER: "uplift-production"

permissions:
  id-token: write
  contents: read

jobs:
  setup:
    name: ğŸ¯ Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should_deploy }}
      ecs-service: ${{ steps.env.outputs.ecs_service }}
      domain: ${{ steps.env.outputs.domain }}
      node-env: ${{ steps.env.outputs.node_env }}

    steps:
      - name: ğŸ¯ Set Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            ENV="development"
          else
            ENV="none"
          fi

          echo "environment=${ENV}" >> $GITHUB_OUTPUT

          # Set deployment flag
          if [[ "${ENV}" == "production" ]] || [[ "${ENV}" == "development" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

          # Set ECS service name
          if [[ "${ENV}" == "production" ]]; then
            echo "ecs_service=web-frontend" >> $GITHUB_OUTPUT
            echo "domain=www.uplifttech.store" >> $GITHUB_OUTPUT
            echo "node_env=production" >> $GITHUB_OUTPUT
          elif [[ "${ENV}" == "development" ]]; then
            echo "ecs_service=web-frontend-dev" >> $GITHUB_OUTPUT
            echo "domain=www.uplifttech.dev" >> $GITHUB_OUTPUT
            echo "node_env=development" >> $GITHUB_OUTPUT
          fi

          echo "ğŸ“ Environment: ${ENV}"
          echo "ğŸš€ Should Deploy: $([ "${ENV}" != "none" ] && echo "Yes" || echo "No")"

  quality-gate:
    name: ğŸ” Quality Gate
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸš€ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: ğŸ“¦ Install Dependencies
        run: npm ci --no-audit --prefer-offline

      - name: ğŸ” Lint Code
        run: npm run lint

      - name: ğŸ”§ Type Check
        run: npx tsc --noEmit

      - name: ğŸ—ï¸ Build Next.js
        env:
          NODE_ENV: ${{ needs.setup.outputs.node-env }}
          NEXT_PUBLIC_ENV: ${{ needs.setup.outputs.environment }}
        run: npm run build

      - name: ğŸ›¡ï¸ Security Audit
        run: npm audit --audit-level=high
        continue-on-error: true

  docker-build-push:
    name: ğŸ³ Build & Push to ECR (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, quality-gate]
    if: needs.setup.outputs.should-deploy == 'true'

    outputs:
      image-digest: ${{ steps.build-push.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-uplift-frontend-${{ needs.setup.outputs.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”‘ Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ·ï¸ Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=sha,format=short,prefix=${{ needs.setup.outputs.environment }}-
            type=raw,value=${{ needs.setup.outputs.environment }}-latest
            type=ref,event=branch
            type=semver,pattern={{version}}

      - name: ğŸ—ï¸ Build & Push Docker Image
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=${{ needs.setup.outputs.node-env }}
            NEXT_PUBLIC_ENV=${{ needs.setup.outputs.environment }}
          cache-from: type=gha,scope=${{ needs.setup.outputs.environment }}
          cache-to: type=gha,mode=max,scope=${{ needs.setup.outputs.environment }}

      - name: ğŸ“‹ Output Image Details
        run: |
          echo "ğŸ·ï¸ Image Tags:"
          echo "${{ steps.meta.outputs.tags }}"
          echo ""
          echo "ğŸ“Œ Digest: ${{ steps.build-push.outputs.digest }}"

  deploy-ecs:
    name: ğŸš€ Deploy to ECS (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, docker-build-push]
    if: needs.setup.outputs.should-deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}

    steps:
      - name: ğŸ” Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-uplift-frontend-deploy-${{ needs.setup.outputs.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”‘ Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ“¥ Download Current Task Definition
        id: download-task-def
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ needs.setup.outputs.ecs-service }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json > task-definition.json

          # Remove unnecessary fields
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            task-definition.json > task-def-clean.json

          echo "ğŸ“‹ Current Task Definition:"
          cat task-def-clean.json | jq .

      - name: ğŸ”„ Update Task Definition with New Image
        id: update-task-def
        run: |
          # Get the new image URI with digest
          NEW_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}@${{ needs.docker-build-push.outputs.image-digest }}"

          echo "ğŸ†• New Image: ${NEW_IMAGE}"

          # Update the container image in task definition
          jq --arg IMAGE "${NEW_IMAGE}" \
             --arg ENV "${{ needs.setup.outputs.node-env }}" \
             --arg PUBLIC_ENV "${{ needs.setup.outputs.environment }}" \
             '.containerDefinitions[0].image = $IMAGE |
              .containerDefinitions[0].environment = [
                {"name": "NODE_ENV", "value": $ENV},
                {"name": "NEXT_PUBLIC_ENV", "value": $PUBLIC_ENV}
              ]' \
            task-def-clean.json > task-definition-new.json

          echo "ğŸ“‹ Updated Task Definition:"
          cat task-definition-new.json | jq .

      - name: ğŸ“ Register New Task Definition
        id: register-task-def
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition-new.json \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task_def_arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "âœ… Registered: ${TASK_DEF_ARN}"

      - name: ğŸš€ Update ECS Service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ needs.setup.outputs.ecs-service }} \
            --task-definition ${{ steps.register-task-def.outputs.task_def_arn }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "âœ… Service update initiated for ${{ needs.setup.outputs.ecs-service }}"

      - name: â³ Wait for Service Stability
        run: |
          echo "â³ Waiting for service to become stable..."
          echo "This may take 2-5 minutes..."

          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ needs.setup.outputs.ecs-service }} \
            --region ${{ env.AWS_REGION }}

          echo "âœ… Service is stable!"

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "## ğŸ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Domain | https://${{ needs.setup.outputs.domain }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Service | ${{ needs.setup.outputs.ecs-service }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ECS Cluster | ${{ env.ECS_CLUSTER }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${{ needs.docker-build-push.outputs.image-tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Digest | \`${{ needs.docker-build-push.outputs.image-digest }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ”— **Test your deployment**: https://${{ needs.setup.outputs.domain }}" >> $GITHUB_STEP_SUMMARY

  health-check:
    name: ğŸ¥ Health Check (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs]
    if: needs.setup.outputs.should-deploy == 'true'

    steps:
      - name: ğŸ¥ Check Application Health
        run: |
          max_attempts=10
          attempt=1
          DOMAIN="${{ needs.setup.outputs.domain }}"

          echo "ğŸ” Starting health check for https://${DOMAIN}"

          while [ $attempt -le $max_attempts ]; do
            echo "ğŸ”„ Health check attempt $attempt/$max_attempts"

            # Try API health endpoint first
            if curl -f -s -k "https://${DOMAIN}/api/health" > /dev/null 2>&1; then
              echo "âœ… API Health check passed!"
              curl -s -k "https://${DOMAIN}/api/health"
              exit 0
            # Fall back to main page
            elif curl -f -s -k -L "https://${DOMAIN}" > /dev/null 2>&1; then
              echo "âœ… Main page is accessible!"
              HTTP_CODE=$(curl -s -k -L -o /dev/null -w "%{http_code}" "https://${DOMAIN}")
              echo "HTTP Status: ${HTTP_CODE}"
              exit 0
            fi

            echo "â³ Attempt $attempt/$max_attempts failed, retrying in 15 seconds..."
            sleep 15
            attempt=$((attempt + 1))
          done

          echo "âš ï¸ Health check did not pass, but deployment completed"
          echo "ğŸ” Attempting to get response information..."
          curl -I -k "https://${DOMAIN}" || true

          # Don't fail the deployment if health check fails
          exit 0

  notify:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs, health-check]
    if: always() && needs.setup.outputs.should-deploy == 'true'

    steps:
      - name: ğŸ“Š Deployment Status
        run: |
          if [[ "${{ needs.deploy-ecs.result }}" == "success" ]]; then
            echo "âœ… Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
            echo "ğŸ”— https://${{ needs.setup.outputs.domain }}"
          else
            echo "âŒ Deployment to ${{ needs.setup.outputs.environment }} failed!"
            exit 1
          fi
